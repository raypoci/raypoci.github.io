//Author: Reimond Poci 
//BU ID: U18561315

import java.util.*;

//creates an event object
class EventK {

	//each event object contains a type {BIRTH,DEATH,MONITOR} and execution time
	String type;
	double execution_time;

	//class constructorf
	public EventK(String type, double execution_time){
		this.type=type;
		this.execution_time=execution_time;
	}
	//returns the execution time of object
	public double get_execution_time(){
		return this.execution_time;
	}

	//generates an exponentially distributed rate
	public static double exp(double lambda){

		Random RandomRun = new Random();
		double RandomVal = RandomRun.nextDouble();

		//return a random variable that follows exponential distribution
		return (-Math.log(1 - RandomVal))/lambda;
}
	//generates an exponentially distributed rate of service
	public static double generate_time_death(){
		return exp(1/simulatorK.service_time);
	}
	//generates an exponentially distributed rate of arrivals
	public static double generate_time_event(){
		return exp(simulatorK.arrival_rate);
	}
}

class EventComparatorK implements Comparator<EventK>{
	//overrides Comparator compare so that we keep Priority Queue sorted by execution time
	public int compare(EventK event1, EventK event2){
		double time = event1.get_execution_time() - event2.get_execution_time();
		if (time>0){
			return 1;
		}
		else if (time<0){return -1;}
		else return 0;
	}


}

//controller class which practically dictates the state of the simulation at each event
public class ControllerK{
	private static RequestK request_server[];
	
	//global constant to keep track on total # of requests
	public static int request_id=0;
	
	//sets id of new request to current request_id and increments request_id by 1
	public static int set_request_id(){
        int birth_id=request_id;
        request_id++;
        return birth_id;
    }
	//initializes scheduke
	public static PriorityQueue<EventK> initializeSchedule(){
		//we use Priority Queue to keep events sorted by execution time
		PriorityQueue<EventK> schedule = new PriorityQueue<EventK>(new EventComparatorK());
		
		//initiate the new schedule with a birth event and a monitor event
		EventK first_event = new EventK("BIRTH", EventK.generate_time_event());
		schedule.add(first_event);

		EventK first_monitor = new EventK("MONITOR", EventK.generate_time_event());
		schedule.add(first_monitor);

		return schedule;

	}

	public static void simulation(double simulation_len, double arrival_rate, double service_time, int total_servers){
		//initiate state of the system
		StateK state = new StateK();
		//initiate schedule for simulation
		PriorityQueue<EventK> schedule = initializeSchedule();

		double time = 0;
		//run for the duration of simulation_len
		while (time<simulation_len){
			//begin processing the first event in the schedule
			EventK event = schedule.remove();
			time = event.get_execution_time();

			//this function is responsible for executing each event
			//takes as parameters state, schedulfe, execution time of the event and event itself
			execute_event(state, schedule, time, event);
		}

		//At the end of while loop we print avg.length of queue, avg.response time, dropped requests
		System.out.println("UTIL: " + (state.service_time / simulation_len));
		System.out.println("QLEN: "+ (state.length / state.monitor));
		System.out.println("TRESP: "+ (state.response_time / state.serviced_request));
		System.out.println("DROPPED: " + state.dropped_request);
   
	}

	public static void execute_event(StateK state, PriorityQueue<EventK> schedule, double time, EventK event){
		//if we have a birth event
		if (event.type == "BIRTH"){

			//set the request id and add it to queue
			int req_id = set_request_id();
			RequestK req = new RequestK(req_id);
			

			//set arrival time of request as current time
			req.set_arrival(time);
	
			if (state.request_queue.size() == simulatorK.queue_len){
				state.dropped_request+=1;
				System.out.println("R" + req.id + " DROP: " + time);
			}

			else
			{
				state.request_queue.add(req);
				System.out.println("R" + Integer.toString(req.id) + " ARR: " + time);
			

			//if this request is the only one in the queue
			if (state.request_queue.size()==1){

				//print out service time
				System.out.println("R" + Integer.toString(req.id) + " START: " + time);
				//begin servicing request and set service time to current time
				req.set_begin_service(time);

				//generate a death event by generating an exponentially distributed death time
				double next_death_time = time + event.generate_time_death();
				EventK death_event = new EventK("DEATH", next_death_time);
				//add death event to schedule
				schedule.add(death_event);

			}}
			//regardless of length of queue we schedule next birth event
			//next event is generated by an exponentially distributed IAT
		
			double next_birth_time = time + event.generate_time_event();
			
			EventK next_birth = new EventK("BIRTH", next_birth_time);
			//add birth event to schedule
			schedule.add(next_birth);
		
	}
		//if event is a death event
		else if (event.type == "DEATH"){
			//we remove the request from queue since its scheduled to "die"
			RequestK req = state.request_queue.remove();

			//record end of service time
			req.set_end_service(time);
			//print out time the request finished being served
			System.out.println("R" + req.id + " DONE: " +req.end_service);
			
			//increase number of requests that finished service by 1
			state.serviced_request += 1;
			
			//increase the total service time of the system by the service time of the request
			double service_time = req.service_time();
			state.service_time+= service_time;
			
			//increase total response time of system by response time of the request
			double response_time = req.response_time();
			state.response_time += response_time;


			//if there are still requests in the queue
			
			if (state.request_queue.size()>0){
				
				//we can set the service time of the next request to be dequeued without removing it
				RequestK next = state.request_queue.peek();
				
				next.set_begin_service(time);
				

				//print out the start of service time of next request
				System.out.println("R" + Integer.toString(next.id) + " START: " + next.begin_service);

				//schedule the next death event and add to schedule
				double next_death_time= time + event.generate_time_death();
				EventK next_death = new EventK("DEATH", next_death_time);
				schedule.add(next_death);


			}

		}
		//monitor event records the state of the system
		else if (event.type=="MONITOR"){

			//generate the next monitor event just like we would a birth event
			double monitor_time = time + event.generate_time_event();
			EventK next_monitor = new EventK("MONITOR", monitor_time);
			schedule.add(next_monitor);
			
			//increase the total number of requests that have been in the system by current size of queue
			state.length += state.request_queue.size();

			//add 1 to the number of monitor events
			state.monitor +=1;
			



		}


	} 
}





